# Cursor Hooks Support - Implementation Plan

## Executive Summary

Cursor hooks are **fundamentally different** from Claude Code hooks:

- **Protocol**: JSON over stdin/stdout vs environment variables
- **Config**: `~/.cursor/hooks.json` vs `.claude/settings.json`
- **Matchers**: None (filter in scripts) vs regex in config
- **Events**: 6 events with different names vs 9 Claude Code events

**Solution**: Hybrid adapter pattern using generated wrapper scripts + native `--cursor-mode` flag.

## Architecture Decision: Hybrid Adapter Pattern

```
Cursor Agent
    â†“ JSON stdin
Wrapper Script (generated by blues-traveler)
    â†“ Environment variables
blues-traveler run <hook> --cursor-mode
    â†“ Exit code
Wrapper Script
    â†“ JSON stdout
Cursor Agent
```

### Why This Works

1. **Wrapper handles protocol translation** - Cursor JSON â†” blues-traveler env vars
2. **Wrapper implements matchers** - Since Cursor has no config-level matchers
3. **--cursor-mode optimizes** - Direct JSON I/O for better performance
4. **Zero breaking changes** - Existing Claude Code support unchanged

## Event Mapping

| Blues-Traveler | Claude Code        | Cursor                 | Notes                        |
| -------------- | ------------------ | ---------------------- | ---------------------------- |
| PreToolUse     | `PreToolUse`       | `beforeShellExecution` | Shell commands only          |
| PreToolUse     | `PreToolUse`       | `beforeMCPExecution`   | MCP tools only               |
| PostToolUse    | `PostToolUse`      | `afterFileEdit`        | File edits only              |
| UserPrompt     | `UserPromptSubmit` | `beforeSubmitPrompt`   | Direct mapping               |
| Stop           | `Stop`             | `stop`                 | Direct mapping               |
| _New_          | N/A                | `beforeReadFile`       | Cursor-only (access control) |

**Not Supported in Cursor**: Notification, SubagentStop, PreCompact, SessionStart, SessionEnd

## Implementation Phases

### Phase 1: Core Infrastructure (Week 1-2)

#### 1.1 Add `--cursor-mode` Flag

```go
// internal/cmd/hooks.go
func runHookCursorMode(hookKey string) error {
    var input CursorHookInput
    json.NewDecoder(os.Stdin).Decode(&input)

    setupEnvironment(input) // Map JSON to env vars
    err := executeHook(hookKey)

    response := CursorHookOutput{Permission: "allow"}
    if err != nil {
        response.Permission = "deny"
        response.UserMessage = err.Error()
    }
    json.NewEncoder(os.Stdout).Encode(response)

    if response.Permission == "deny" {
        os.Exit(3)
    }
    return nil
}
```

#### 1.2 Wrapper Script Generator

```go
// internal/platform/cursor/wrapper.go
func GenerateWrapperScript(hookKey, matcher, event string) (string, error) {
    template := `#!/bin/bash
# Auto-generated Cursor hook wrapper
# Hook: {{.HookKey}} | Event: {{.CursorEvent}} | Matcher: {{.Matcher}}

input=$(cat)
{{.ParseEnvVars}}
{{.MatcherLogic}}

if blues-traveler run {{.HookKey}} --cursor-mode <<< "$input"; then
    echo '{"permission": "allow"}'
else
    echo '{"permission": "deny", "userMessage": "Hook {{.HookKey}} failed"}'
    exit 3
fi
`
    return executeTemplate(template, data)
}
```

#### 1.3 Cursor Config Handler

```go
// internal/platform/cursor/config.go
type CursorHooksConfig struct {
    Version int                       `json:"version"`
    Hooks   map[string][]CursorHook   `json:"hooks"`
}

func (c *CursorHooksConfig) AddHook(event, scriptPath string) {
    if c.Hooks[event] == nil {
        c.Hooks[event] = []CursorHook{}
    }
    c.Hooks[event] = append(c.Hooks[event], CursorHook{Command: scriptPath})
}
```

### Phase 2: CLI Integration (Week 2-3)

#### 2.1 Platform-Aware Install

```bash
# Auto-detect platform
blues-traveler hooks install security --event PreToolUse --matcher ".*\.go$"

# Explicit platform (Cursor)
blues-traveler hooks install security --platform cursor --event beforeShellExecution

# Result for Cursor:
# 1. Generates ~/.cursor/hooks/blues-traveler-security-beforeShellExecution.sh
# 2. Updates ~/.cursor/hooks.json
# 3. Makes script executable
```

#### 2.2 Platform Detection

```go
// internal/platform/detect.go
func DetectPlatform() Platform {
    // 1. Check env var
    if p := os.Getenv("BLUES_TRAVELER_PLATFORM"); p != "" {
        return FromString(p)
    }
    // 2. Check for .cursor/ directory
    if _, err := os.Stat(".cursor"); err == nil {
        return cursor.NewCursorPlatform()
    }
    // 3. Check for .claude/ directory
    if _, err := os.Stat(".claude"); err == nil {
        return claude.NewClaudeCodePlatform()
    }
    // 4. Default to Claude Code (backward compat)
    return claude.NewClaudeCodePlatform()
}
```

### Phase 3: Testing & Documentation (Week 3-4)

#### 3.1 Testing

```go
// Test wrapper generation
func TestGenerateWrapperScript(t *testing.T) {
    wrapper, err := GenerateWrapperScript("security", ".*\\.go$", "beforeShellExecution")
    assert.NoError(t, err)
    assert.Contains(t, wrapper, "blues-traveler run security --cursor-mode")
}

// Test JSON I/O mode
func TestCursorMode(t *testing.T) {
    input := `{"hook_event_name": "beforeShellExecution", "command": "rm -rf /"}`
    cmd := exec.Command("blues-traveler", "run", "security", "--cursor-mode")
    cmd.Stdin = strings.NewReader(input)
    output, _ := cmd.Output()

    var response CursorHookOutput
    json.Unmarshal(output, &response)
    assert.Equal(t, "deny", response.Permission)
}
```

#### 3.2 Documentation

- Update README.md with Cursor section
- Create Cursor quick start guide
- Document platform flag usage
- Update CLAUDE.md with platform support notes

## Implementation Checklist

### Week 1-2: Core âœ… COMPLETE

- [x] Implement `--cursor-mode` flag with JSON I/O
- [x] Create wrapper script generator with template system
- [x] Build Cursor config file handler (`~/.cursor/hooks.json`)
- [x] Event name mapper (Generic â†” Cursor)
- [x] Unit tests for wrapper generation

### Week 2-3: CLI âœ… COMPLETE

- [x] Add `--platform` flag to all commands
- [x] Platform auto-detection logic
- [x] Update `hooks install` for Cursor
- [x] Create `blues-traveler platform detect` command
- [x] Integration test: install hook on Cursor

### Week 3-4: Polish ðŸš§ IN PROGRESS

- [ ] Full hook execution in Cursor mode (convert events, call handlers) **PRIORITY**
- [ ] Custom hooks support for Cursor
- [ ] Cross-platform sync command
- [ ] Update all documentation to be platform-agnostic
- [ ] All documentation updates
- [ ] Migration guide (optional)
- [ ] Beta release announcement

## File Structure

### New Files

```
internal/platform/
  â”œâ”€â”€ platform.go          # Platform interface
  â”œâ”€â”€ detect.go            # Auto-detection logic
  â”œâ”€â”€ claude/
  â”‚   â””â”€â”€ platform.go      # Claude Code impl
  â””â”€â”€ cursor/
      â”œâ”€â”€ platform.go      # Cursor impl
      â”œâ”€â”€ config.go        # hooks.json handler
      â”œâ”€â”€ wrapper.go       # Wrapper generator
      â””â”€â”€ templates/
          â””â”€â”€ wrapper.sh.tmpl
```

### Modified Files

```
internal/cmd/hooks.go      # Add --cursor-mode, --platform
main.go                    # Platform flag on root cmd
```

## Success Criteria

1. âœ… Can install security hook in Cursor - **COMPLETE**
2. â¸ï¸ Hook blocks dangerous commands in Cursor - **Phase 3** (currently allows all)
3. âœ… Wrapper scripts generate correctly with matchers - **COMPLETE**
4. âœ… Platform auto-detection works (`.cursor/` vs `.claude/`) - **COMPLETE**
5. âœ… All existing Claude Code tests pass (zero breaking changes) - **COMPLETE**
6. âœ… Documentation covers both platforms - **COMPLETE**

## Risks & Mitigations

| Risk                             | Mitigation                                 |
| -------------------------------- | ------------------------------------------ |
| Cursor API changes               | Version detection, fallback strategies     |
| Breaking Claude Code support     | Comprehensive regression test suite        |
| Platform abstraction too complex | Start simple, iterate on actual needs      |
| User confusion                   | Clear docs, sensible defaults, good errors |

## Example: Installing Security Hook

### Claude Code (Unchanged)

```bash
blues-traveler hooks install security --event PreToolUse
# Result: Updates .claude/settings.json
```

### Cursor (New)

```bash
blues-traveler hooks install security --platform cursor --event beforeShellExecution
# Result:
# 1. Generates ~/.cursor/hooks/blues-traveler-security.sh:
#    #!/bin/bash
#    input=$(cat)
#    export EVENT_NAME=$(echo "$input" | jq -r '.hook_event_name')
#    export TOOL_ARGS=$(echo "$input" | jq -r '.command')
#    if blues-traveler run security --cursor-mode <<< "$input"; then
#      echo '{"permission": "allow"}'
#    else
#      echo '{"permission": "deny", "userMessage": "Security check failed"}'
#      exit 3
#    fi
#
# 2. Updates ~/.cursor/hooks.json:
#    {
#      "version": 1,
#      "hooks": {
#        "beforeShellExecution": [
#          {"command": "~/.cursor/hooks/blues-traveler-security.sh"}
#        ]
#      }
#    }
```

---

**Status**: âœ… Phase 2 Complete | ðŸš§ Phase 3 In Progress
**Timeline**: 1-2 weeks to beta release
**Next**: Implement executeCursorHook for full hook execution in Cursor mode

## Phase 2 Achievements (2024-09-30)

- âœ… Platform detection and info commands
- âœ… `--platform cursor` flag on install command
- âœ… Automatic wrapper script generation
- âœ… Cursor config management (`~/.cursor/hooks.json`)
- âœ… JSON I/O protocol support
- âœ… Basic integration (hooks allow all operations)

## Known Limitation

Hooks in Cursor mode currently allow all operations without executing hook logic. The cchooks Runner tries to read from stdin, which has already been consumed in Cursor mode. This will be fixed in Phase 3 by implementing executeCursorHook to convert Cursor JSON to cchooks events and call handlers directly.
