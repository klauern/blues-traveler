# Hook Implementation Guide

## Hook Structure

Every hook follows this pattern:

```go
package hooks

import (
    "github.com/klauern/blues-traveler/internal/core"
    "github.com/brads3290/cchooks"
)

type MyHook struct {
    *core.BaseHook
}

func NewMyHook(ctx *core.HookContext) core.Hook {
    base := core.NewBaseHook("myhook", "My Hook", "Description", ctx)
    return &MyHook{BaseHook: base}
}

func (h *MyHook) Run() error {
    if !h.IsEnabled() {
        return nil
    }

    // Register event handlers
    runner := cchooks.NewRunner()
    runner.PreToolUse(h.preToolUseHandler)
    runner.PostToolUse(h.postToolUseHandler)

    return runner.Run()
}

// Event handlers
func (h *MyHook) preToolUseHandler(ctx context.Context, event *cchooks.PreToolUseEvent) cchooks.PreToolUseResponseInterface {
    // Log event
    h.LogHookEvent("PreToolUse", event.ToolName, nil, nil)

    // Hook logic here
    if shouldBlock {
        return cchooks.PreToolUseResponse{
            ToolAllowed: false,
            ToolDeniedMessage: "Blocked by MyHook",
        }
    }

    return cchooks.PreToolUseResponse{ToolAllowed: true}
}
```

## Registration

Add to `builtinHooks` in [internal/hooks/init.go](mdc:internal/hooks/init.go):

```go
func init() {
    builtinHooks := map[string]core.HookFactory{
        "security":      NewSecurityHook,
        "format":        NewFormatHook,
        "myhook":        NewMyHook,  // Add here
    }
    core.RegisterBuiltinHooks(builtinHooks)
}
```

## Event Handlers

### PreToolUse
- **Purpose**: Validate/block before tool execution
- **Response**: Allow/deny with optional message
- **Common uses**: Security, validation

### PostToolUse
- **Purpose**: React after tool execution
- **Response**: Optional message to user
- **Common uses**: Formatting, testing, notifications

## Logging

Use `LogHookEvent` for structured logging:

```go
h.LogHookEvent("event_name", "tool_name", map[string]interface{}{
    "file": filePath,
    "action": "formatted",
}, nil)
```

## Testing Pattern

```go
func TestMyHook(t *testing.T) {
    ctx := &core.HookContext{
        Settings: &config.Settings{
            Plugins: map[string]config.PluginConfig{
                "myhook": {Enabled: &[]bool{true}[0]},
            },
        },
    }

    hook := NewMyHook(ctx)
    err := hook.Run()
    assert.NoError(t, err)
}
```

## Built-in Hooks Reference

| Hook | Event | Purpose |
|------|-------|---------|
| `security` | PreToolUse | Block dangerous commands |
| `format` | PostToolUse | Auto-format code files |
| `debug` | All | Log to blues-traveler.log |
| `audit` | All | JSON audit logging |
| `vet` | PostToolUse | Type checking (Python) |
| `fetch-blocker` | PreToolUse | Block fetch URLs |
| `find-blocker` | PreToolUse | Suggest fd over find |

## Best Practices

1. **Always use BaseHook** - Don't reimplement interface methods
2. **Check IsEnabled()** - Respect user configuration
3. **Log events** - Use LogHookEvent for consistency
4. **Handle errors gracefully** - Return errors, don't panic
5. **Keep hooks focused** - One clear purpose per hook
6. **Document behavior** - Clear descriptions and comments

2. **Independent Execution**: No dependencies between hooks
3. **Settings-Based Configuration**: Use `IsEnabled()` and settings
4. **Structured Logging**: Use LogHookEvent for consistency
